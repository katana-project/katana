// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package v1

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ErrorType.
const (
	BadRequest        ErrorType = "bad_request"
	InternalError     ErrorType = "internal_error"
	MissingCapability ErrorType = "missing_capability"
	NotFound          ErrorType = "not_found"
	UnknownFormat     ErrorType = "unknown_format"
)

// Defines values for ImageMode.
const (
	All   ImageMode = "all"
	Basic ImageMode = "basic"
	None  ImageMode = "none"
)

// Defines values for ImageType.
const (
	ImageTypeAvatar   ImageType = "avatar"
	ImageTypeBackdrop ImageType = "backdrop"
	ImageTypePoster   ImageType = "poster"
	ImageTypeStill    ImageType = "still"
	ImageTypeUnknown  ImageType = "unknown"
)

// Defines values for MediaFormatType.
const (
	Mkv MediaFormatType = "mkv"
	Mp4 MediaFormatType = "mp4"
	Raw MediaFormatType = "raw"
)

// Defines values for MetadataType.
const (
	MetadataTypeEpisode MetadataType = "episode"
	MetadataTypeMovie   MetadataType = "movie"
	MetadataTypeSeries  MetadataType = "series"
	MetadataTypeUnknown MetadataType = "unknown"
)

// Defines values for RepositoryCapability.
const (
	Index     RepositoryCapability = "index"
	Remux     RepositoryCapability = "remux"
	Transcode RepositoryCapability = "transcode"
	Watch     RepositoryCapability = "watch"
)

// CastMember defines model for CastMember.
type CastMember struct {
	Image *Image `json:"image,omitempty"`

	// Name The cast member name.
	Name string `json:"name"`

	// Role The cast character name or the member's position.
	Role string `json:"role"`
}

// EpisodeMetadata defines model for EpisodeMetadata.
type EpisodeMetadata struct {
	// Episode The episode number.
	Episode int `json:"episode"`

	// Images The promotional images of the media.
	Images []Image `json:"images"`

	// OriginalTitle The media title as it was initially released (original language).
	OriginalTitle *string `json:"original_title"`

	// Overview The media plot overview.
	Overview *string `json:"overview"`

	// ReleaseDate The media initial release date and time.
	ReleaseDate time.Time `json:"release_date"`

	// Season The season containing the episode.
	Season int            `json:"season"`
	Series SeriesMetadata `json:"series"`

	// Title The media title.
	Title string       `json:"title"`
	Type  MetadataType `json:"type"`

	// VoteRating The media like/dislike ratio.
	VoteRating float32 `json:"vote_rating"`
}

// Error defines model for Error.
type Error struct {
	// Description The error description.
	Description string    `json:"description"`
	Type        ErrorType `json:"type"`
}

// ErrorType defines model for ErrorType.
type ErrorType string

// Image defines model for Image.
type Image struct {
	// Description The image description.
	Description *string `json:"description"`

	// Path The image URL, a remote HTTP resource or raw data (data:image url).
	Path string `json:"path"`

	// Remote Whether the image path is a remote URL.
	Remote bool      `json:"remote"`
	Type   ImageType `json:"type"`
}

// ImageMode defines model for ImageMode.
type ImageMode string

// ImageType defines model for ImageType.
type ImageType string

// Media defines model for Media.
type Media struct {
	// Id The media ID, alphanumeric, lowercase, non-blank ([a-z0-9-_]).
	Id   string      `json:"id"`
	Meta *Media_Meta `json:"meta"`
}

// Media_Meta defines model for Media.Meta.
type Media_Meta struct {
	union json.RawMessage
}

// MediaFormat defines model for MediaFormat.
type MediaFormat struct {
	// Extension The format's preferred file extension, *without leading dots*.
	Extension string `json:"extension"`

	// Mime The format MIME type.
	Mime string `json:"mime"`

	// Name The container format name.
	Name *string `json:"name"`
}

// MediaFormatType defines model for MediaFormatType.
type MediaFormatType string

// MediaVariant defines model for MediaVariant.
type MediaVariant struct {
	Format MediaFormat `json:"format"`

	// Id The media ID, alphanumeric, lowercase, non-blank ([a-z0-9-_]).
	Id   string             `json:"id"`
	Meta *MediaVariant_Meta `json:"meta"`
}

// MediaVariant_Meta defines model for MediaVariant.Meta.
type MediaVariant_Meta struct {
	union json.RawMessage
}

// Metadata defines model for Metadata.
type Metadata struct {
	// Images The promotional images of the media.
	Images []Image `json:"images"`

	// OriginalTitle The media title as it was initially released (original language).
	OriginalTitle *string `json:"original_title"`

	// Overview The media plot overview.
	Overview *string `json:"overview"`

	// ReleaseDate The media initial release date and time.
	ReleaseDate time.Time `json:"release_date"`

	// Title The media title.
	Title string       `json:"title"`
	Type  MetadataType `json:"type"`

	// VoteRating The media like/dislike ratio.
	VoteRating float32 `json:"vote_rating"`
}

// MetadataType defines model for MetadataType.
type MetadataType string

// MovieMetadata defines model for MovieMetadata.
type MovieMetadata struct {
	// Cast The people casted in the media.
	Cast []CastMember `json:"cast"`

	// Countries The countries that took part in producing the media.
	Countries []string `json:"countries"`

	// Genres The media's genres.
	Genres []string `json:"genres"`

	// Images The promotional images of the media.
	Images []Image `json:"images"`

	// Languages The languages originally spoken in the media.
	Languages []string `json:"languages"`

	// OriginalTitle The media title as it was initially released (original language).
	OriginalTitle *string `json:"original_title"`

	// Overview The media plot overview.
	Overview *string `json:"overview"`

	// ReleaseDate The media initial release date and time.
	ReleaseDate time.Time `json:"release_date"`

	// Title The media title.
	Title string       `json:"title"`
	Type  MetadataType `json:"type"`

	// VoteRating The media like/dislike ratio.
	VoteRating float32 `json:"vote_rating"`
}

// Repository defines model for Repository.
type Repository struct {
	// Capabilities The repository's capabilities.
	Capabilities []RepositoryCapability `json:"capabilities"`

	// Id The repository ID, alphanumeric, lowercase, non-blank ([a-z0-9-_]).
	Id string `json:"id"`

	// Name The repository name.
	Name string `json:"name"`
}

// RepositoryCapability defines model for RepositoryCapability.
type RepositoryCapability string

// SeriesMetadata defines model for SeriesMetadata.
type SeriesMetadata struct {
	// Cast The people casted in the media.
	Cast []CastMember `json:"cast"`

	// Countries The countries that took part in producing the media.
	Countries []string `json:"countries"`

	// Genres The media's genres.
	Genres []string `json:"genres"`

	// Images The promotional images of the media.
	Images []Image `json:"images"`

	// Languages The languages originally spoken in the media.
	Languages []string `json:"languages"`

	// OriginalTitle The media title as it was initially released (original language).
	OriginalTitle *string `json:"original_title"`

	// Overview The media plot overview.
	Overview *string `json:"overview"`

	// ReleaseDate The media initial release date and time.
	ReleaseDate time.Time `json:"release_date"`

	// Title The media title.
	Title string       `json:"title"`
	Type  MetadataType `json:"type"`

	// VoteRating The media like/dislike ratio.
	VoteRating float32 `json:"vote_rating"`
}

// GetRepoMediaParams defines parameters for GetRepoMedia.
type GetRepoMediaParams struct {
	// Images The image fetching mode.
	Images *ImageMode `form:"images,omitempty" json:"images,omitempty"`
}

// AsMetadata returns the union data inside the Media_Meta as a Metadata
func (t Media_Meta) AsMetadata() (Metadata, error) {
	var body Metadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetadata overwrites any union data inside the Media_Meta as the provided Metadata
func (t *Media_Meta) FromMetadata(v Metadata) error {
	v.Type = "unknown"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetadata performs a merge with any union data inside the Media_Meta, using the provided Metadata
func (t *Media_Meta) MergeMetadata(v Metadata) error {
	v.Type = "unknown"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMovieMetadata returns the union data inside the Media_Meta as a MovieMetadata
func (t Media_Meta) AsMovieMetadata() (MovieMetadata, error) {
	var body MovieMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMovieMetadata overwrites any union data inside the Media_Meta as the provided MovieMetadata
func (t *Media_Meta) FromMovieMetadata(v MovieMetadata) error {
	v.Type = "movie"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMovieMetadata performs a merge with any union data inside the Media_Meta, using the provided MovieMetadata
func (t *Media_Meta) MergeMovieMetadata(v MovieMetadata) error {
	v.Type = "movie"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSeriesMetadata returns the union data inside the Media_Meta as a SeriesMetadata
func (t Media_Meta) AsSeriesMetadata() (SeriesMetadata, error) {
	var body SeriesMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSeriesMetadata overwrites any union data inside the Media_Meta as the provided SeriesMetadata
func (t *Media_Meta) FromSeriesMetadata(v SeriesMetadata) error {
	v.Type = "series"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSeriesMetadata performs a merge with any union data inside the Media_Meta, using the provided SeriesMetadata
func (t *Media_Meta) MergeSeriesMetadata(v SeriesMetadata) error {
	v.Type = "series"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEpisodeMetadata returns the union data inside the Media_Meta as a EpisodeMetadata
func (t Media_Meta) AsEpisodeMetadata() (EpisodeMetadata, error) {
	var body EpisodeMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEpisodeMetadata overwrites any union data inside the Media_Meta as the provided EpisodeMetadata
func (t *Media_Meta) FromEpisodeMetadata(v EpisodeMetadata) error {
	v.Type = "episode"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEpisodeMetadata performs a merge with any union data inside the Media_Meta, using the provided EpisodeMetadata
func (t *Media_Meta) MergeEpisodeMetadata(v EpisodeMetadata) error {
	v.Type = "episode"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Media_Meta) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Media_Meta) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "episode":
		return t.AsEpisodeMetadata()
	case "movie":
		return t.AsMovieMetadata()
	case "series":
		return t.AsSeriesMetadata()
	case "unknown":
		return t.AsMetadata()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Media_Meta) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Media_Meta) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMetadata returns the union data inside the MediaVariant_Meta as a Metadata
func (t MediaVariant_Meta) AsMetadata() (Metadata, error) {
	var body Metadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetadata overwrites any union data inside the MediaVariant_Meta as the provided Metadata
func (t *MediaVariant_Meta) FromMetadata(v Metadata) error {
	v.Type = "unknown"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetadata performs a merge with any union data inside the MediaVariant_Meta, using the provided Metadata
func (t *MediaVariant_Meta) MergeMetadata(v Metadata) error {
	v.Type = "unknown"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMovieMetadata returns the union data inside the MediaVariant_Meta as a MovieMetadata
func (t MediaVariant_Meta) AsMovieMetadata() (MovieMetadata, error) {
	var body MovieMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMovieMetadata overwrites any union data inside the MediaVariant_Meta as the provided MovieMetadata
func (t *MediaVariant_Meta) FromMovieMetadata(v MovieMetadata) error {
	v.Type = "movie"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMovieMetadata performs a merge with any union data inside the MediaVariant_Meta, using the provided MovieMetadata
func (t *MediaVariant_Meta) MergeMovieMetadata(v MovieMetadata) error {
	v.Type = "movie"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSeriesMetadata returns the union data inside the MediaVariant_Meta as a SeriesMetadata
func (t MediaVariant_Meta) AsSeriesMetadata() (SeriesMetadata, error) {
	var body SeriesMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSeriesMetadata overwrites any union data inside the MediaVariant_Meta as the provided SeriesMetadata
func (t *MediaVariant_Meta) FromSeriesMetadata(v SeriesMetadata) error {
	v.Type = "series"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSeriesMetadata performs a merge with any union data inside the MediaVariant_Meta, using the provided SeriesMetadata
func (t *MediaVariant_Meta) MergeSeriesMetadata(v SeriesMetadata) error {
	v.Type = "series"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEpisodeMetadata returns the union data inside the MediaVariant_Meta as a EpisodeMetadata
func (t MediaVariant_Meta) AsEpisodeMetadata() (EpisodeMetadata, error) {
	var body EpisodeMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEpisodeMetadata overwrites any union data inside the MediaVariant_Meta as the provided EpisodeMetadata
func (t *MediaVariant_Meta) FromEpisodeMetadata(v EpisodeMetadata) error {
	v.Type = "episode"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEpisodeMetadata performs a merge with any union data inside the MediaVariant_Meta, using the provided EpisodeMetadata
func (t *MediaVariant_Meta) MergeEpisodeMetadata(v EpisodeMetadata) error {
	v.Type = "episode"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t MediaVariant_Meta) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MediaVariant_Meta) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "episode":
		return t.AsEpisodeMetadata()
	case "movie":
		return t.AsMovieMetadata()
	case "series":
		return t.AsSeriesMetadata()
	case "unknown":
		return t.AsMetadata()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MediaVariant_Meta) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MediaVariant_Meta) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
